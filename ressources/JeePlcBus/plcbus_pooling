#!/usr/bin/perl -w

###############################################################################
#
# Created by Wayne Thomas, contributions by Maurice de Bijl
#
# Listens on the designated TCP port for correctly formatted commands and passes them to the 
# PLCBUS adaptor then returns the response.
#
#	 Initial version by Wayne Thomas, based upon hub_plcbus.pl (written
#	 by Jfn of  domoticaforum) with some code borrowed from Ron Frazier
# 	(http://www.ronfrazier.net).
#
# Latest version and discussion, see http://code.google.com/p/plcbus-daemon-for-linux/
# History, see http://code.google.com/p/plcbus-daemon-for-linux/source/list
#
# Feel free to do anything you want with this, as long as you
# include the above attribution.
#
#
# For more information, execute 'plcbus.pl --info'
#
###############################################################################

use Device::SerialPort;
use IO::Socket;
use Time::HiRes qw(sleep);
use IO::Socket::INET;
use SerialLibs::IOSelectBuffered;
use List::Util qw(sum);
use Getopt::Long;
use File::Pid;

my $verbose = '';		# verbose flag, default is false
my $serdev = '/dev/ttyUSB-PLCBus';	# default serial device, typically COM1
my $plcbus_usercode = '0xFF';	# default usercode, value can be (00-FF) 
my $phase = 1;			# number of phases, valid values are 1 or 3
my $serport;                    # handle for the serial port

# Hash containing relation between ASCII command and PLCBUS command hex code
#
my %plcbus_command_to_hex = (
	'ALL_UNITS_OFF'		=> 0x00,
	'ALL_LIGHTS_ON'		=> 0x01,
	'ON'			=> 0x02,
	'OFF'			=> 0x03,
	'DIM'			=> 0x04,
	'BRIGHT'		=> 0x05,
	'ALL_LIGHTS_OFF'	=> 0x06,
	'ALL_USER_LIGHTS_ON'	=> 0x07,
	'ALL_USER_UNITS_OFF'	=> 0x08,
	'ALL_USER_LIGHTS_OFF'	=> 0x09,
	'BLINK'			=> 0x0a,
	'FADE_STOP'		=> 0x0b,
	'PRESET_DIM'		=> 0x0c,
#	'STATUS_ON'		=> 0x0d,
#	'STATUS_OFF'		=> 0x0e,
	'STATUS_REQUEST'	=> 0x0f,
	'RX_MASTER_ADDR_SETUP'	=> 0x10,
	'TX_MASTER_ADDR_SETUP'	=> 0x11,
	'SCENE_ADDR_SETUP'	=> 0x12,
	'SCENE_ADDR_ERASE'	=> 0x13,
	'ALL_SCENES_ADDR_ERASE'	=> 0x14,
	'GET_SIGNAL_STRENGTH'	=> 0x18,
	'GET_NOISE_STRENGTH'	=> 0x19,
#	'REPORT_SIGNAL_STRENGTH'=> 0x1a,
#	'REPORT_NOISE_STRENGTH' => 0x1b,
	'GET_ALL_ID_PULSE'	=> 0x1c,
	'GET_ON_ID_PULSE'	=> 0x1d,
#	'REPORT_ALL_ID_PULSE'	=> 0x1e,
#	'REPORT_ON_ID_PULSE'	=> 0x1f, 
);



# Convert hex code to status messages 
#
my %plcbus_hex_to_status = (
	0x00    => "ALL_UNITS_OFF",
	0x01	=> "ALL_LIGHTS_ON",
	0x02	=> "ON",
	0x03	=> "OFF",
	0x04	=> "DIM",
	0x05	=> "BRIGHT",
    0x06    => "ALL_LIGHTS_OFF",
	0x07    => "ALL_USER_LIGHTS_ON",
	0x08    => "ALL_USER_UNITS_OFF",
	0x09    => "ALL_USER_LIGHTS_OFF",
    0x0a    => "BLINK",
	0x0b    => "FADE_STOP",
    0x0c    => "PRESET_DIM",
	0x0d	=> "STATUS_ON",
	0x0e	=> "STATUS_OFF",
	0x0f    => "STATUS_REQUEST",
	0x10    => "RX_MASTER_ADDR_SETUP",
	0x11    => "TX_MASTER_ADDR_SETUP",
	0x12    => "SCENE_ADDR_SETUP",
	0x13    => "SCENE_ADDR_ERASE",
	0x14    => "ALL_SCENES_ADDR_ERASE",
	0x18    => "GET_SIGNAL_STRENGTH",
	0x19    => "GET_NOISE_STRENGTH",
	0x1a    => "REPORT_SIGNAL_STRENGTH",
	0x1b    => "REPORT_NOISE_STRENGTH",
	0x1c    => "GET_ALL_ID_PULSE",
	0x1d    => "GET_ON_ID_PULSE",
	0x1e	=> "REPORT_ALL_ID_PULSE",
	0x1f    => "REPORT_ON_ID_PULSE",
);


	

# Did we receive a proper status request for a device?
#
sub plcbus_rx_status
{
	my ($homeunit, $action, @data) = @_;
	my $status = sprintf ("%d", $data[4] & 0x1F);
	$action = $action & 0x1F unless !(defined($action));

	# if response is a direct response to the command issued
	#
	if (($status == 0x0D) || ($status == 0x0E) || ((defined($homeunit)) && ($homeunit != $data[3]))) { 
		print("Detected traffic initiated by seperate transmitter\n") if $verbose; 
		# TODO: decipher and send report regarding detected traffic
		plcbus_output_message (@data);
		return 0;
	}
	elsif (!defined $homeunit) {
		print ("Detected traffic initiated by seperate transmitter\n") if $verbose;
		return 1;
	}
	else {
		return 0; }
}

# Output the Received PLCBUS packet
#
sub plcbus_output_message 
{
	my (@data) = @_;
	my $test = sprintf ("%d", $data[4] & 0x1f);
	return 0 unless (defined($plcbus_hex_to_status{$test}));
	$plcbus_status = $plcbus_hex_to_status{$test};
	my $home = int($data[3] / 16) + 65;
	$home = pack ("C", $home);
	my $unit = $data[3] % 16 + 1;
	$plcbus_status = $home.$unit . ',' . $plcbus_status . ',' . $data[5] . ',' . $data[6];
	print ($plcbus_status."\n");
	return $plcbus_status;
}


#
# Start of MAIN program
#

my $pidFile       = "/tmp/jeedom_plcbus.pid";

# create pid file
my $pidfile = File::Pid->new( { file => $pidFile, } );
 
$pidfile->write or die "Can't write PID file, /dev/null: $!";


my $help = '';
my $info = '';

# Process any options passed in
#
GetOptions (	'verbose' =>	\$verbose,
		'help' =>	\$help,
		'info' =>	\$info,
		'user=s' =>	\$plcbus_usercode,
		'phase=i' =>	\$phase,
		'device=s' =>	\$serdev);
if ($help) { help(); exit 0;}
if ($info) { info(); exit 0;}

$plcbus_usercode = hex ($plcbus_usercode);
die "Invalid UserCode - Valid values are 00 - FF. Stopped\n" if (($plcbus_usercode < 0x00) || ($plcbus_usercode > 0xFF));
die "Invalid number of Phases - Legal values are 1 or 3. Stopped\n" unless (($phase == 1) || ($phase == 3));

# Open serial port to the PLCBUS controller
#
$serport=Device::SerialPort->new($serdev) or die "Error opening serial port: $!\n";
$serport->baudrate(9600);
$serport->databits(8);
$serport->parity("none");
$serport->stopbits(1);
$serport->handshake("none");
$serport->write_settings;
$serport->read_const_time(200);


my $select = new SerialLibs::IOSelectBuffered();

LOOP : while()
{

		my $result;
		do {
			$result = plcbus_rx_status();
		} while $result;
		next;
};

exit;
