#!/usr/bin/perl -w

###############################################################################
#
# Created by Wayne Thomas, contributions by Maurice de Bijl
#
# Listens on the designated TCP port for correctly formatted commands and passes them to the 
# PLCBUS adaptor then returns the response.
#
#	 Initial version by Wayne Thomas, based upon hub_plcbus.pl (written
#	 by Jfn of  domoticaforum) with some code borrowed from Ron Frazier
# 	(http://www.ronfrazier.net).
#
# Latest version and discussion, see http://code.google.com/p/plcbus-daemon-for-linux/
# History, see http://code.google.com/p/plcbus-daemon-for-linux/source/list
#
# Feel free to do anything you want with this, as long as you
# include the above attribution.
#
#
# For more information, execute 'plcbus.pl --info'
#
###############################################################################

use Device::SerialPort;
use Time::HiRes qw(sleep);
use SerialLibs::IOSelectBuffered;
use List::Util qw(sum);
use Getopt::Long;


my $verbose = '';		# verbose flag, default is false
my $serdev = '';	# default serial device, typically COM1
my $plcbus_usercode = '0xFF';	# default usercode, value can be (00-FF) 
my $phase = 1;			# number of phases, valid values are 1 or 3
my $serport;                    # handle for the serial port

		
# Hash containing relation between ASCII command and PLCBUS command hex code
#
my %plcbus_command_to_hex = (
	'ALL_UNITS_OFF'		=> 0x00,
	'ALL_LIGHTS_ON'		=> 0x01,
	'ON'			=> 0x02,
	'OFF'			=> 0x03,
	'DIM'			=> 0x04,
	'BRIGHT'		=> 0x05,
	'ALL_LIGHTS_OFF'	=> 0x06,
	'ALL_USER_LIGHTS_ON'	=> 0x07,
	'ALL_USER_UNITS_OFF'	=> 0x08,
	'ALL_USER_LIGHTS_OFF'	=> 0x09,
	'BLINK'			=> 0x0a,
	'FADE_STOP'		=> 0x0b,
	'PRESET_DIM'		=> 0x0c,
#	'STATUS_ON'		=> 0x0d,
#	'STATUS_OFF'		=> 0x0e,
	'STATUS_REQUEST'	=> 0x0f,
	'RX_MASTER_ADDR_SETUP'	=> 0x10,
	'TX_MASTER_ADDR_SETUP'	=> 0x11,
	'SCENE_ADDR_SETUP'	=> 0x12,
	'SCENE_ADDR_ERASE'	=> 0x13,
	'ALL_SCENES_ADDR_ERASE'	=> 0x14,
	'GET_SIGNAL_STRENGTH'	=> 0x18,
	'GET_NOISE_STRENGTH'	=> 0x19,
#	'REPORT_SIGNAL_STRENGTH'=> 0x1a,
#	'REPORT_NOISE_STRENGTH' => 0x1b,
	'GET_ALL_ID_PULSE'	=> 0x1c,
	'GET_ON_ID_PULSE'	=> 0x1d,
#	'REPORT_ALL_ID_PULSE'	=> 0x1e,
#	'REPORT_ON_ID_PULSE'	=> 0x1f, 
);



# Convert hex code to status messages 
#
my %plcbus_hex_to_status = (
	0x00    => "ALL_UNITS_OFF",
	0x01	=> "ALL_LIGHTS_ON",
	0x02	=> "ON",
	0x03	=> "OFF",
	0x04	=> "DIM",
	0x05	=> "BRIGHT",
    0x06    => "ALL_LIGHTS_OFF",
	0x07    => "ALL_USER_LIGHTS_ON",
	0x08    => "ALL_USER_UNITS_OFF",
	0x09    => "ALL_USER_LIGHTS_OFF",
    0x0a    => "BLINK",
	0x0b    => "FADE_STOP",
    0x0c    => "PRESET_DIM",
	0x0d	=> "ON",
	0x0e	=> "OFF",
	0x0f    => "STATUS_REQUEST",
	0x10    => "RX_MASTER_ADDR_SETUP",
	0x11    => "TX_MASTER_ADDR_SETUP",
	0x12    => "SCENE_ADDR_SETUP",
	0x13    => "SCENE_ADDR_ERASE",
	0x14    => "ALL_SCENES_ADDR_ERASE",
	0x18    => "GET_SIGNAL_STRENGTH",
	0x19    => "GET_NOISE_STRENGTH",
	0x1a    => "REPORT_SIGNAL_STRENGTH",
	0x1b    => "REPORT_NOISE_STRENGTH",
	0x1c    => "GET_ALL_ID_PULSE",
	0x1d    => "GET_ON_ID_PULSE",
	0x1e	=> "REPORT_ALL_ID_PULSE",
	0x1f    => "REPORT_ON_ID_PULSE",
);


# Send command to PLCBUS
#
sub plcbus_tx_command
{
	my ($params) = @_;
	$params = uc($params);
	$plcbus_data1 = 0x0;
	$plcbus_data2 = 0x0;
	my $result;

	my @params_data = split(/\,/, $params); # Split the command in its various parts (Example: A1,ON; D4,DIM,10,1)
	if (!defined($params_data[1])) {
		print ("ERROR Illegal Command Format\:\:") if $verbose;
		return 0;
	}
	my @homeunit = split(//, $params_data[0]);
	my $home = unpack ('C*', $homeunit[0]) - 65;
	my $unit = substr ($params_data[0], 1, 2);
	if (($home =~ /\D/) || ($home < 0) || ($home > 16) || ($unit =~ /\D/) || ($unit <1) || ($unit > 16)) {
		print ("ERROR Illegal HomeUnit Code\:\:") if $verbose;
		return 0;
	}
	my $plcbus_homeunit = $home*16 + $unit - 1;

	# provide some flexibility in command syntax
	$params_data[1] =~ s/-/_/g;
	$params_data[1] =~ s/ /_/g;

	# if command is not valid return to main
	if (!defined ($plcbus_command_to_hex{$params_data[1]})) {
		print ("ERROR Unknown PLCBUS Command\:\:") if $verbose;
		return 0;
	}

	# prepare command and data for transmission
	$plcbus_command = ($plcbus_command_to_hex {$params_data[1]});
	if (($plcbus_command >= 0x1C) || ($plcbus_command <= 0x1) || (($plcbus_command >= 0x06) && ($plcbus_command <=0x09))) {
		$plcbus_homeunit &= 0xF0; }
	$plcbus_command += 0x20 unless (($plcbus_command == 0x1C) || ($plcbus_command == 0x1D));
	$plcbus_command += 0x40 if ($phase == 3);
	$plcbus_data1 = $params_data[2] if defined($params_data[2]);
	if (($plcbus_data1 =~/\D/) || ($plcbus_data1 < 0) || ($plcbus_data1 > 100)) {
		print ("ERROR Illegal Data1 Value\:\:") if $verbose;
		return 0;
	}
	$plcbus_data2 = $params_data[3] if defined($params_data[3]);
	if (($plcbus_data2 =~/\D/) || ($plcbus_data2 < 0) || ($plcbus_data2 > 100)) {
		print ("ERROR Illegal Data2 Value\:\:") if $verbose;
		return 0;
	}

	$plcbus_frame = pack ('C*', 0x02, 0x05, $plcbus_usercode, $plcbus_homeunit, $plcbus_command, $plcbus_data1, $plcbus_data2, 0x03);

	# Empty any loafing data from the serial buffer
	while (1)
	{
		my ($bytes, $plcbus_frame) = $serport->read(9);
		last if $bytes == 0;
		my @params_data = unpack ('C*', $plcbus_frame);

                if (plcbus_rx_valid_frame (@params_data))
                {
                	if (plcbus_rx_status(undef,undef, @params_data))        # Did we receive a valid frame and does it contain a$
               		{
				plcbus_output_message (@params_data);
			}
		}
	}

	foreach (1..3)
	{
		# send prepared command to controller
		$serport->write ($plcbus_frame);
		#sprintf ("Sent Packet     = 02 05 %02x %02x %02x %02x %02x 03\n", 
		#	$plcbus_usercode, $plcbus_homeunit, $plcbus_command, $plcbus_data1, $plcbus_data2) if ($verbose);

		# listen for feedback
		$result = plcbus_check_status($plcbus_homeunit, $plcbus_command);
		last unless (!$result);
	}
	print ("ERROR pas de reponse\:\:") if !$result;
	return $result;
}


# Read and decode incoming PLCBUS frames
#
sub plcbus_check_status
{
	# One transmitted command over the PLCBUS will result in two or three return packets, including a status message
	# We listen for a maximum of 3 seconds for all packets received and filter out the relevant status. Should we 
	# receive it earlier, then break from the loop
	my ($homeunit, $action) = @_;
	my $plcbus_status = '';
	eval
	{
		local $SIG{ALRM} = sub { die };
		alarm 1;
		READ : while (1)
		{
			my $plcbus_frame=$serport->read(9);
			my @params_data = unpack ('C*', $plcbus_frame);
                        
			if (plcbus_rx_valid_frame (@params_data))
			{
				if (plcbus_rx_status($homeunit, $action, @params_data))	# Did we receive a valid frame and does it contain a status message
				{
					$plcbus_status = plcbus_output_message (@params_data);
					last READ if $plcbus_status;
				}
			}
		}
		alarm 0;
	} or return 0;
	return $plcbus_status;
}
	

# Checks whether the received response is a valid PLCBUS frame
#
sub plcbus_rx_valid_frame
{
	my (@data) = @_;

	# Did we receive a valid 9 byte PLCBUS frame?
	if (scalar @data == 9)
	{
		#sprintf("Received Packet = %02X %02X %02X %02X %02X %02X %02X %02X %02X",
		#	$data[0], $data[1], $data[2], $data[3], $data[4], $data[5], $data[6], $data[7], $data[8]) if $verbose;

		# Does it have a payload of six bytes and start with STX and ends with ETX?
		if (($data[1] == 0x06) && ($data[0] == 0x02) && (($data[8] == 0x03)
		
		# Support for the PLCBUS-1141 PLUS (+) computer interface
		|| ((sum(@data) % 0x100) == 0x0)))
		{
			# Yes it does, we have a valid frame!
		        print ("\:\:") if $verbose;
			return 1;
		} else
		{
			# Bummer, better luck next time
			print (" - not a valid frame\:\:") if $verbose;
			return 0;
		}
	}
}

# Did we receive a proper status request for a device?
#
sub plcbus_rx_status
{
	my ($homeunit, $action, @data) = @_;
	my $status = sprintf ("%d", $data[4] & 0x1F);
	$action = $action & 0x1F unless !(defined($action));

	# if response is a direct response to the command issued
	#
	if ((defined($homeunit)) && ($homeunit == $data[3])) {

		# if using three phase, wait for status report from coupler
		#
		if ($phase == 3) {
			if (($data[4] == 0x0D) || ($data[4] == 0x0E) || ($data[4] >= 0x1E)) {
				return 1; }
		}

		# if a get ID query command wait for a rxed ID Feedback signal
		#
		elsif (($action == 0x1C) || ($action == 0x1D)) {
			if ($data[7] == 0x40) {
				return 1; }
		}

		# if a query command (request or get) wait for a PLCBUS success report from another unit (not the 1141(+))
		#
		elsif (($action == 0x0F) || ($action == 0x18) || ($action == 0x19)) {
			if ($data[7] == 0x0C) {
				return 1; }
		}

		# if a scene setup / erase, or a on / off to a scene address (Unit 10 - 16 for each Home) only send success is required
		#
		elsif (($action == 0x12) || ($action == 0x13) || ($action == 0x14) ||
				((($action == 0x02) || ($action == 0x03)) && (($data[3] & 0x0F) >= 0x09))) {
			if ($data[7] == 0x1C) {
				return 1; }
		}

		# all other commands only require an ACK 
		elsif ($data[7] == 0x20) {
			return 1; };
	}
	elsif (($status == 0x0D) || ($status == 0x0E) || ((defined($homeunit)) && ($homeunit != $data[3]))) { 
		print ("Detected traffic initiated by seperate transmitter\:\:") if $verbose; 
		# TODO: decipher and send report regarding detected traffic
		plcbus_output_message (@data);
		return 0;
	}
	elsif (!defined $homeunit) {
		print ("Detected traffic initiated by seperate transmitter\:\:") if $verbose;
		return 1;
	}
	else {
		return 0; }
}

# Output the Received PLCBUS packet
#
sub plcbus_output_message 
{
	my (@data) = @_;
	my $test = sprintf ("%d", $data[4] & 0x1f);
	return 0 unless (defined($plcbus_hex_to_status{$test}));
	$plcbus_status = $plcbus_hex_to_status{$test};
	my $home = int($data[3] / 16) + 65;
	$home = pack ("C", $home);
	my $unit = $data[3] % 16 + 1;
	$plcbus_status = $home.$unit . ',' . $plcbus_status . ',' . $data[5] . ',' . $data[6];
	print ("$plcbus_status\:\:");
	return $plcbus_status;
}


my $d_code = '';
my $d_cmd = '';
my $d_data1 = '';
my $d_data2 = '';

# Process any options passed in
#
GetOptions (	'verbose' =>	\$verbose,
		'user=s' =>	\$plcbus_usercode,
		'phase=i' =>	\$phase,
		'device=s' =>	\$serdev,
		'd_code=s' =>	\$d_code,
		'd_cmd=s' =>	\$d_cmd,
		'd_data1=s' =>	\$d_data1,
		'd_data2=s' =>	\$d_data2);

$plcbus_usercode = hex ($plcbus_usercode);
die "Invalid UserCode - Valid values are 00 - FF. Stopped\n" if (($plcbus_usercode < 0x00) || ($plcbus_usercode > 0xFF));
die "Invalid number of Phases - Legal values are 1 or 3. Stopped\n" unless (($phase == 1) || ($phase == 3));

# Open serial port to the PLCBUS controller
#
#$serport=Device::SerialPort->new($serdev) or die "Error opening serial port: $!\:\:";
#$serport->baudrate(9600);
#$serport->databits(8);
#$serport->parity("none");
#$serport->stopbits(1);
#$serport->handshake("none");
#$serport->write_settings;
#$serport->read_const_time(200);

$serport = new Device::SerialPort($serdev,'','') || die "Impossible d'ouvrir le $serdev\:\:";
$serport->baudrate(9600) || die "Impossible de configurer en 9600";
$serport->parity('none') || die "Impossible de configurer la parité none";
$serport->databits(8)  || die "Impossible de configurer 8 bits de données";
$serport->stopbits(1)  || die "Impossible de configurer 1 bit de stop";
$serport->handshake('none')  || die "Impossible de configurer le control de flux matériel inactif";
$serport->write_settings;
$serport->read_const_time(200);

if ($d_code eq '')
{
	my $res = plcbus_check_status();

} else {
	my $d_cmd_param = $d_code . ',' . $d_cmd . ',' . $d_data1 . ',' . $d_data2;
	my $plcbus_result = plcbus_tx_command ($d_cmd_param);
}

$serport->close();

exit;